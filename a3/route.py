"""
route2.py
Marc-Andre Descoteaux
V00847029
CSC361 Assignment 3
The purpose of this program is to analyze a pcap file generated by a traceroute command and output findings.
"""

import sys
import math
from pypacker import ppcap
from pypacker.layer12 import ethernet
from pypacker.layer3 import ip
from pypacker.layer3 import icmp
from pypacker.layer4 import udp
#from pypacker.layer3 import ip_shared as protolist

# global variables
debug = False
hopping = True
linux = False
window = False
packet_num = 0
true_src = 'none'
true_dst = 'none'
fst_gram = 0
inter_node = {}
protocols = {}
id_ttl = {}
frags = {}
time_start = {}
time_end = {}
offset = {}
short_ttl = 0
ttl_list = {}
inter_ports = {}
dest_ports = []
id_port = {}
#frag_ports = {}
#port_id = {}

# convert nanosecond to seconds on timestamps
def nano_to_sec(nans):
	
	return nans / 1000000000
# convert nanosecond to milliseconds on timestamps
def nano_to_msec(nans):
	
	return nans / 1000000
	
def addProto(protocol):

	global protocols
	# only doing a few known/likely protocols for simplicity in this assignment. Thinking of implementing fully with Regex against ip_shared.py
	if protocol == ip.IP_PROTO_ICMP:
		protocols['1'] = 'ICMP'
	elif protocol == ip.IP_PROTO_UDP:
		protocols['17'] = 'UDP'
	else:
		protocols[str(protocol)] = 'Other'
	
def readLinux(head):
	global debug
	global frags
	global true_dst
	global true_src
	global offset
	global short_ttl # shortest ttl that reached destination
	global inter_ports
	global dest_ports
	global ttl_list
	global hopping
	global id_port
	#global port_id
	#global frag_ports
	fragged = False
	

	src_ip = head[0]
	dst_ip = head[1]
	protocol = head[2]
	ttl = head[3]
	ttl = str(ttl)
	id = head[4]
	flags = head[5]
	head_length = head[6]
	length = head[7]
	ts = head[8]
	eth = head[9]
	off = eth[ip.IP].off
	
	addProto(protocol)
	
	if id not in frags:
		frags[id] = 0
	else:
		fragged = True
	if flags == 1:
		frags[id] = frags[id] + 1
			
	offset[id] = off
	
	if not fragged:
		if protocol == ip.IP_PROTO_UDP:
			src_port = eth[ip.IP][udp.UDP].sport
			dst_port = eth[ip.IP][udp.UDP].dport
			if debug:
				print("UDP")
				print("src port", src_port)
				print("dst port", dst_port)
			
			id_port[src_port] = id
			

			time_start[src_port] = ts
				
			if ttl not in inter_ports:
				inter_ports[ttl] = [src_port]
			else:
				inter_ports[ttl].append(src_port)
			
			ttl_list[src_port] = ttl
				
		if protocol == ip.IP_PROTO_ICMP:
			if debug:
				print("ICMP found")
			
			type = eth[icmp.ICMP].type
			
			if type == icmp.ICMP_TIMEXCEED:
				if debug:
					print("TTL exceeded")
				
				# get the body of the ICMP message
				orig_bts = eth[ip.IP].body_bytes
				icmp1 = icmp.ICMP(orig_bts)
				icmp_bts = icmp1.body_bytes
				ip_bts = icmp_bts[4:] # 4 bytes at end of type 11 are unused
				#icmp_bts = icmp_bts[24:]
				ip1 = ip.IP(ip_bts)
				udp1 = udp.UDP(ip1.body_bytes)
				#udp1 = udp.UDP(icmp_bts)
				src_port = udp1.sport
				if debug:
					print(orig_bts)
					print(icmp1)
					print(ip1)
					print(udp1)
					print(src_port)
				#if dst_ip == true_src:
				inter_node[src_port] = src_ip
					
			elif type == icmp.ICMP_UNREACH:
				if debug:
					print("Port Unreachable")
				# get the body of the ICMP message
				orig_bts = eth[icmp.ICMP.Unreach].body_bytes
				ip1 = ip.IP(orig_bts)
				udp1 = udp.UDP(ip1.body_bytes)
				ttl = ip1.ttl
				src_port = udp1.sport
				if debug:
					print(orig_bts)
					print(ip1)
					print(udp1)
					print(ttl)
					print(src_port)
				
				if hopping:
					if dst_ip == true_src and src_ip == true_dst:
						hopping = False
						short_ttl = int(ttl_list.get(src_port))
						if debug:
							print(ttl_list)
							print("short_ttl", short_ttl)
				dest_ports.append(src_port)
			time_end[src_port] = ts
			
def readWindow(head):
	global debug
	global frags
	global true_dst
	global true_src
	global offset
	global short_ttl # shortest ttl that reached destination
	global inter_ports
	global dest_ports
	global ttl_list
	global hopping
	global id_port
	fragged = False
	

	src_ip = head[0]
	dst_ip = head[1]
	protocol = head[2]
	ttl = head[3]
	ttl = str(ttl)
	id = head[4]
	flags = head[5]
	head_length = head[6]
	length = head[7]
	ts = head[8]
	eth = head[9]
	off = eth[ip.IP].off
	
	addProto(protocol)
	
	if id not in frags:
		frags[id] = 0
	else:
		fragged = True
	if flags == 1:
		frags[id] = frags[id] + 1
			
	offset[id] = off
	
	if not fragged:
		
		if protocol == ip.IP_PROTO_ICMP:
			if debug:
				print("ICMP found")
			
			type = eth[icmp.ICMP].type
			
			if type == icmp.ICMP_TIMEXCEED:
				if debug:
					print("TTL exceeded")
				
				# get the body of the ICMP message
				orig_bts = eth[ip.IP].body_bytes
				icmp1 = icmp.ICMP(orig_bts)
				icmp_bts = icmp1.body_bytes
				icmp_bts = icmp_bts[4:]
				ip1 = ip.IP(icmp_bts)
				icmp2 = ip1[icmp.ICMP.Echo]
				seq = icmp2.seq
				
				if debug:
					print(orig_bts)
					print(icmp1)
					print(ip1)
					print(icmp2)
					print(seq)
				
				inter_node[seq] = src_ip
					
			elif type == 8:
				if debug:
					print("Request")
					
				orig_bts = eth[ip.IP].body_bytes
				icmp1 = eth[icmp.ICMP.Echo]
				seq = icmp1.seq
				icmp_id = icmp1.id
				
				if debug:
					print(orig_bts)
					print(icmp1)
					print(id)
					print(icmp_id)
					print(seq)
					
				time_start[seq] = ts
				
				if ttl not in inter_ports:
					inter_ports[ttl] = [seq]
				else:
					inter_ports[ttl].append(seq)
			
				ttl_list[seq] = ttl
				
			elif type == 0:
				if debug: 
					print("Reply")
					
				orig_bts = eth[ip.IP].body_bytes
				icmp1 = eth[icmp.ICMP.Echo]
				seq = icmp1.seq
				icmp_id = icmp1.id
				
				if debug:
					#print(orig_bts)
					print(icmp1)
					print(id)
					print(icmp_id)
					print(seq)
					
				
				if hopping:
					if dst_ip == true_src and src_ip == true_dst:
						hopping = False
						short_ttl = int(ttl_list.get(seq))
						if debug:
							#print(ttl_list)
							print("short_ttl", short_ttl)
							
				dest_ports.append(seq)
			
			time_end[seq] = ts
					
				
			
	

#read packets from file and parse IP header
def readPacks(file):
	global debug
	global packet_num
	global true_src
	global true_dst
	global fst_gram
	global ttl_list
	found = False
	global linux 
	global window 
	
	pcap = ppcap.Reader(filename=file)
		
	for ts, buf in pcap:
		packet_num += 1
		eth = ethernet.Ethernet(buf)
		ts = nano_to_msec(ts)
		pack = eth[ip.IP]
		if pack is not None:
			if debug:
				print("-----------------")
				print("Frame:",packet_num)
				print("%d: %s -> %s" % (ts, eth[ip.IP].src_s, eth[ip.IP].dst_s))
		# get information about packet
			src_ip = pack.src_s
			dst_ip = pack.dst_s
			protocol = pack.p
			ttl = pack.ttl
			id = pack.id
			flags = pack.flags
			head_length = pack.hl
			length = len(buf)
			
			if debug:
				print("source ip",src_ip)
				print("dest ip",dst_ip)
				print("protocol",protocol)
				print("ttl",ttl)
				print("id",id)
				print("flags",flags)
				print("header",head_length)
				print("length",length)
				print("\nData:")
			
			if not found and ttl == 1:
				true_src = src_ip
				true_dst = dst_ip
				found = True
				if protocol == ip.IP_PROTO_UDP:
					linux = True
					fst_gram = pack[udp.UDP].sport
					if debug:
						print("Linux Traceroute begins:")
				elif protocol == ip.IP_PROTO_ICMP and eth[icmp.ICMP].type == icmp.ICMP_TYPE_ECHO_RESP:
					window = True
					fst_gram = id
					if debug:
						print("Windows Traceroute begins:")
				else:
					found = False
						
			head = (src_ip, dst_ip, protocol, ttl, id, flags, head_length, length, ts, eth)
			if (protocol == ip.IP_PROTO_UDP or protocol == ip.IP_PROTO_ICMP) and linux:
				readLinux(head)
			elif window and protocol == ip.IP_PROTO_ICMP:
				readWindow(head)


				
def print_proto():

	global protocols
	
	for key in sorted(protocols):
		print ("\t%s: %s" % (key, protocols[key]))
	print("\n")
	
def router_list():

	global inter_node
	global short_ttl
	global inter_ports
	
	i = 1
	if debug:
		print(inter_node)
		print(inter_ports)
	while(i < short_ttl):
		print("\trouter %d: %s" % (i, inter_node.get(inter_ports.get(str(i))[0])))
		i += 1
	print("\n")
	
def calc_inter_rtt(port):
	global debug
	global time_end
	global time_start
	avg = 0
	sd = 0
	times = []
	if debug:
		print(port)
	for p in port:
		if p is not None and p in time_end:
			t = time_end.get(p) - time_start.get(p)
			times.append(t)
	if len(times) > 0:
		avg = sum(times)/len(times)
		var = [math.pow((t - avg),2) for t in times]
		var = sum(var)/len(var)
		sd = math.sqrt(var)
	
	if debug:
		print(times)
		print(avg)
		print(sd)
	return avg, sd
	
def calc_dest_rtt():
	global debug
	global time_end
	global time_start
	global dest_ports
	avg = 0
	sd = 0
	times = []
	for p in dest_ports:
		t = time_end.get(p) - time_start.get(p)
		times.append(t)
	avg = sum(times)/len(times)
	var = [math.pow((t - avg), 2) for t in times]
	var = sum(var)/len(var)
	sd = math.sqrt(var)
	
	if debug:
		print(times)
		print(avg)
		print(sd)
	return avg, sd
	
def print_rtt():
	
	global true_src
	global true_dst
	global inter_node
	global short_ttl
	global inter_ports
	global dest_ports
	
	i = 1
	
	while(i < short_ttl):
		
		port = inter_ports.get(str(i))
		node = inter_node.get(port[0])
		if node is not None:
			avg, sd = calc_inter_rtt(port)
			print("The avg RTT between %s and %s is: %0.4f ms, the s.d. is %0.4f ms" % (true_src, node, avg, sd))
			i += 1
	
	avg, sd = calc_dest_rtt()
	print("The avg RTT between %s and %s is: %.4f ms, the s.d. is %.4f ms" % (true_src, true_dst, avg, sd))
	
	
	
def output():

	global true_dst
	global true_src
	global protocols
	global frags
	global fst_gram
	global offset
	global id_port
	global linux
	global window
	
	print("The IP address of the source node:", true_src)
	print("The IP address of ultimate destination node:",true_dst)
	print("The IP addresses of the intermediate destination nodes:")
	router_list()
	print("The values in the protocol field of IP headers:")
	print_proto()
	if linux:
		id = id_port.get(fst_gram)
	elif window:
		id = fst_gram
	print("The number of fragments created from the original datagram is:", frags[fst_gram])
	print("The offset of the last fragment is:", offset[id])
	print("\n")
	print_rtt()
	
	
def output2():

	router_list()
	# avg rtt for same inter_nodes
	
def main():

	global debug
	# check for debugging argument
	if len(sys.argv) > 2:
		if sys.argv[2] == "--debug" or sys.argv[2] == "-d":
			debug = True
			print("\nIn Debug Mode:\n")
	if len(sys.argv) > 3:
		sys.stdout = open(str(sys.argv[3]), 'w')
	
	fi = str(sys.argv[1])
	
	if debug:
		print("Program start...")
		print("File:",fi)
		print("Begin reading packets...")
	
	readPacks(fi)
	
	if debug:
		print("All packets read.")
	
	output()
	if debug:
		output2()
	

	if sys.argv[2] is not None and sys.argv[2] == "-o":
		sys.stdout.close()

if __name__ == '__main__':
	main()
